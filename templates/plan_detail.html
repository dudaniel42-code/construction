{% extends 'base.html' %}
{% block content %}
    <section class="plan-detail">
        <div class="layout-split">
            <div class="model-panel">
                <button onclick="toggleView()">Switch View</button>
                <div id="3dView" style="display: block;">
                    <div id="canvasContainer">
                        <canvas id="renderCanvas"></canvas>
                    </div>
                </div>
                <div id="baseView" style="display: none;">
                    <img src="{{ url_for('static', filename='uploads/' + plan.image_path) }}" alt="{{ plan.title }}" loading="lazy" onclick="zoomImage(this.src)">
                </div>
                <div id="zoomModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 1000;">
                    <img id="zoomImg" style="max-width: 90%; max-height: 90%; margin: auto; display: block; position: absolute; top: 5%; left: 5%;">
                    <button onclick="closeZoom()" style="position: absolute; top: 10px; right: 10px; background: white; padding: 0.5rem;">Close</button>
                </div>
            </div>
            <div class="info-panel">
                <h2>{{ plan.title }}</h2>
                <p>{{ plan.description }}</p>
            </div>
        </div>
    </section>
    <script>
        const canvas = document.getElementById("renderCanvas");
        const engine = new BABYLON.Engine(canvas, true);
        const layout = JSON.parse('{{ plan.layout_data | safe }}' || '{}');
        const createScene = function () {
            const scene = new BABYLON.Scene(engine);
            const camera = new BABYLON.ArcRotateCamera("camera", Math.PI / 2, Math.PI / 4, 10, BABYLON.Vector3.Zero(), scene);
            camera.attachControl(canvas, true);
            const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);

            // Ground plane
            const ground = BABYLON.MeshBuilder.CreatePlane("ground", { size: 20 }, scene);
            ground.rotation.x = Math.PI / 2;
            ground.position.y = -0.1;
            ground.material = new BABYLON.StandardMaterial("groundMat", scene);
            ground.material.diffuseColor = new BABYLON.Color3(0.8, 0.8, 0.8);

            // Render walls as extruded lines
            if (layout.walls) {
                layout.walls.forEach(wall => {
                    const points = [
                        new BABYLON.Vector3(wall.start[0], 0, wall.start[2]),
                        new BABYLON.Vector3(wall.end[0], 0, wall.end[2]),
                        new BABYLON.Vector3(wall.end[0], wall.height, wall.end[2]),
                        new BABYLON.Vector3(wall.start[0], wall.height, wall.start[2])
                    ];
                    const wallMesh = BABYLON.MeshBuilder.CreatePolygon("wall", { points: points, sideOrientation: BABYLON.Mesh.DOUBLESIDE }, scene);
                    wallMesh.material = new BABYLON.StandardMaterial("wallMat", scene);
                    wallMesh.material.diffuseColor = BABYLON.Color3.FromHexString(wall.color || "#D4A59A");
                });
            }

            // Add decors
            if (layout.decors) {
                layout.decors.forEach(decor => {
                    const decorBox = BABYLON.MeshBuilder.CreateBox("decor_" + decor.type, { size: 1 }, scene);
                    decorBox.scaling = new BABYLON.Vector3(decor.size[0], decor.size[1], decor.size[2]);
                    decorBox.position = new BABYLON.Vector3(decor.position[0], decor.position[1], decor.position[2]);
                    decorBox.material = new BABYLON.StandardMaterial("decorMat", scene);
                    decorBox.material.diffuseColor = BABYLON.Color3.FromHexString(decor.color || "#8A9A5B");
                });
            }

            // Dynamic fit
            const boundingBox = scene.getBoundingBoxOfMeshes(true);
            if (boundingBox) {
                const size = boundingBox.maximum.subtract(boundingBox.minimum);
                const maxDim = Math.max(size.x, size.y, size.z);
                camera.radius = maxDim * 1.5;
                camera.target = boundingBox.center;
                camera.upperRadiusLimit = maxDim * 3;
                camera.lowerRadiusLimit = maxDim * 0.1;
            }

            return scene;
        };
        const scene = createScene();
        engine.runRenderLoop(function () {
            scene.render();
        });
        window.addEventListener("resize", function () {
            engine.resize();
        });

        // Toggle view
        function toggleView() {
            const _3d = document.getElementById("3dView");
            const base = document.getElementById("baseView");
            if (_3d.style.display === "block") {
                _3d.style.display = "none";
                base.style.display = "block";
            } else {
                _3d.style.display = "block";
                base.style.display = "none";
            }
        }

        // Zoom modal
        function zoomImage(src) {
            document.getElementById("zoomModal").style.display = "block";
            document.getElementById("zoomImg").src = src;
        }
        function closeZoom() {
            document.getElementById("zoomModal").style.display = "none";
        }
    </script>
    <style>
        .layout-split {
            display: flex;
            gap: 2rem;
        }
        .model-panel {
            flex: 1;
        }
        #canvasContainer {
            width: 100%;
            height: 500px;
        }
        #baseView img {
            max-width: 100%;
            cursor: zoom-in;
        }
        #zoomImg {
            cursor: zoom-out;
        }
    </style>
{% endblock %}